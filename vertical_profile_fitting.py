# -*- coding: utf-8 -*-
"""Vertical Profile Fitting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KrUGPE5hSmEoNzULOQ16-ZuXoj4mJp8K

Resources:

Scipy, optimize a function with argument dependent constraints

https://stackoverflow.com/questions/31289023/scipy-optimize-a-function-with-argument-dependent-constraints


Optimization with SciPy and application ideas to machine learning

https://towardsdatascience.com/optimization-with-scipy-and-application-ideas-to-machine-learning-81d39c7938b8
"""

#@title Imports & Loading Excel Files

# Imports
from prompt_toolkit.shortcuts.progress_bar.base import E
import matplotlib.pyplot as plt
import scipy.optimize as optimize
from scipy.optimize import Bounds, NonlinearConstraint, SR1
import math
import copy
import pandas as pd
import numpy as np
from google.colab import files
import random as rand
from sklearn import preprocessing

# User Input Values
Initial_Value_Type = "Import EXCEL of Init Values" #@param ["Import EXCEL of Init Values", "Guess Initial Values"]
#@markdown To Export Profiles: Use ORD Tool Reports -> Profile Reports . Use format CivilGeometry -> VerticalAlignmentToTIW.xls. Ensure values are formatted as numbers (i.e. Station 40300, not Station 403+00). To Export: File -> Save As -> *.xlsx.
#@markdown
#@markdown If "Guess Initial Values" is selected - only choose sample points excel file.
#@markdown
#@markdown If "Import EXCEL of Init Values" is selected - only choose sample points excel file, then you will be prompted to choose another file, and then choose the profile guess excel file.

# Upload Sample Points EXCEL file to local Python Directory
!rm *
print()
print()
print("Choose Excel File for Profile/Survey Data you are trying to match.")
uploaded1 = files.upload()
uploaded1_str = str(uploaded1)
file_name1 = uploaded1_str.split(':')[0]
file_name1 = file_name1[2:len(file_name1)-1]

#Extract File Data for Sample Points EXCEL File
mydata = pd.read_excel(file_name1)
mydata = np.array(mydata)
temp_arr = []
for p in mydata:
  temp2 = []
  str_split = p[0].split(' ')
  for s in str_split:
    if len(s) > 2:
      temp2 += [float(s)]
  temp_arr += [temp2]

mydata_array = np.array(temp_arr[0:len(temp_arr)-1])
mydata_arr_T = np.transpose(mydata_array)

if  Initial_Value_Type == "Import EXCEL of Init Values":
  # Upload Profile Guess EXCEL file to local Python Directory
  !rm *
  print()
  print()
  print("Choose Excel File for the 'guess profile' you exported.")
  uploaded2 = files.upload()
  uploaded2_str = str(uploaded2)
  file_name2 = uploaded2_str.split(':')[0]
  file_name2 = file_name2[2:len(file_name2)-1]

  #Extract File Data for Profile Guess EXCEL file
  read_excel_arr = pd.read_excel(file_name2)
  g_arr = np.array(read_excel_arr)

#@title Run Optimization

'''
GLOBAL VARIABLES
____________________________________________________________________________
'''

global Number_Of_Curves
global number_of_params
global num_of_pts
global bounds_error
bounds_error = 1000

from bokeh.plotting import figure, output_file, show
graph = figure(title = "Bokeh Line Graph")

'''
HELPER FUNCTIONS
____________________________________________________________________________
'''

'''   Calculate Average Vertical Error - Print to User
Input: p (numpy array of equation paramters)
Output: average_vertical_error in inches
'''
def calc_total_error(p):
  total_error = 0

  eq_list = get_eq_from_params(p)[0]
  func_ranges = get_eq_from_params(p)[1]

  #Calculate Error
  for x_index in range(len(x_actual)):
    cont_loop = True
    c = 0
    x = x_actual[x_index] + XM
    while cont_loop:
      if x < func_ranges[c] or c == len(func_ranges) - 1:
        if c % 2 == 0:
          y_calc = eq_list[c][0]*x + eq_list[c][1]
        else:
          y_calc = eq_list[c][0]*x**2 + eq_list[c][1]*x + eq_list[c][2]
        cont_loop = False
      c += 1
    diff = y_calc - (y_actual[x_index] + YM)
    total_error += abs(diff)
  #print(total_error)
  return total_error/num_of_pts

'''   XXX
Input: p (numpy array of equation paramters)
Output: XXX
'''
def get_eq_from_params(p):
  # Establish x, y and length arrays
  x_a = p[0:Number_Of_Curves + 2]
  y_a = p[Number_Of_Curves + 2: 2* (Number_Of_Curves + 2)]
  L_a = p[2*(2+Number_Of_Curves): number_of_params]

  # Slope Array
  m_a = []
  for m in range(len(x_a)-1):
    m_a += [(y_a[m+1] - y_a[m])/(x_a[m+1] - x_a[m])]

  # K-Value Array
  k_a = []
  for k in range(Number_Of_Curves):
    k_a += [L_a[k] / (100*abs(m_a[k] - m_a[k+1]))]

  # Ranges between curves and tangents
  func_ranges = []
  for f in range(len(L_a)):
    func_ranges += [x_a[f+1]-L_a[f]/2]
    func_ranges += [x_a[f+1]+L_a[f]/2]

  # Generate Equation
  eq_list = []
  for e in range(Number_Of_Curves):
    #Add Line to Equation
    A = m_a[int(e)] # A = m
    B = y_a[int(e)]-A*x_a[int(e)] # B = y1 - mx1
    eq_list += [[A,B]]


    m1 = m_a[int(e)]
    m2 = m_a[1+int(e)]
    x1 = x_a[int(e)]
    x2 = x_a[1+int(e)]
    y1 = y_a[int(e)]
    y2 = y_a[1+int(e)]
    L = L_a[int(e)]

    A = (m2-m1) / (2*L)
    B =m1 - 2*A*(x2 - L/2)
    xt = x2 - 0.5*L
    yt = y2 - m1*0.5*L
    C = yt - A*xt**2 - B*xt
    #print(m1, " ",m2, " ",x1, " ",x2, " ",y1, " ",y2, " ",L, " ", xt, " ", yt)
    eq_list += [[A,B,C]]

  #Final Tangent
  e=Number_Of_Curves
  A = m_a[int(e)] # A = m
  B = y_a[int(e)]-A*x_a[int(e)] # B = y1 - mx1
  eq_list += [[A,B]]

  return [eq_list, func_ranges, m_a, k_a]

'''   XXX
Input: p (numpy array of equation paramters), x
Output: XXX
'''
def get_y_from_x_and_params(p, x):
  eq_list = get_eq_from_params(p)[0]
  func_ranges = get_eq_from_params(p)[1]

  cont_loop = True
  c = 0
  while cont_loop:
    if x < func_ranges[c] or c == len(func_ranges) - 1:
      if c % 2 == 0:
        y_calc = eq_list[c][0]*x + eq_list[c][1]
      else:
        y_calc = eq_list[c][0]*x**2 + eq_list[c][1]*x + eq_list[c][2]
      cont_loop = False
    c += 1
  return y_calc

'''   XXX
Input: p (numpy array of equation paramters), x
Output: XXX
'''
def get_yArray_from_xArray_and_params(p, x_arr):
  eq_list = get_eq_from_params(p)[0]
  func_ranges = get_eq_from_params(p)[1]

  y_arr = []

  #Calculate Error
  for x_index in range(len(x_arr)):
    cont_loop = True
    c = 0
    x = x_arr[x_index]
    while cont_loop:
      if x < func_ranges[c] or c == len(func_ranges) - 1:
        if c % 2 == 0:
          y_calc = eq_list[c][0]*x + eq_list[c][1]
        else:
          y_calc = eq_list[c][0]*x**2 + eq_list[c][1]*x + eq_list[c][2]
        cont_loop = False
      c += 1
    y_arr += [y_calc]
  return y_arr

'''   XXX
Input: p (numpy array of equation paramters), x
Output: XXX
'''
def graph(formula, x_range, color='r'):
    x = np.array(x_range)
    y = eval(formula)
    graph.line(x, y)
    #plt.plot(x, y, color)

'''   XXX
Input: p (numpy array of equation paramters), x
Output: XXX
'''
def print_graph_from_params(p, color='r'):
  eq_list = get_eq_from_params(p)[0]
  func_ranges = get_eq_from_params(p)[1]

  #Graph First Line
  graph(str(eq_list[0][0]) + '*x+' + str(eq_list[0][1]), range(int(func_ranges[0]-1000), int(func_ranges[0])), color)

  #Loop for rest of Graph
  for c in range(Number_Of_Curves):
    #Graph Curve #C
    curve_str = str(eq_list[c*2+1][0]) + '*x**2+' + str(eq_list[c*2+1][1]) + '*x+' + str(eq_list[c*2+1][2])
    graph(curve_str, range(int(func_ranges[2*c]), int(func_ranges[2*c+1])), color)

    #Graph Line Following Curve #C
    if c == Number_Of_Curves - 1:
      end_range_line = int(func_ranges[2*c+1]) + 1000
    else:
      end_range_line = int(func_ranges[2*c+2])
    line_str = str(eq_list[c*2+2][0]) + '*x+' + str(eq_list[c*2+2][1])
    graph(line_str, range(int(func_ranges[2*c+1]), end_range_line), color)

'''
____________________________________________________________________________
STEP 0:
Global Variables & User Defined Input
____________________________________________________________________________
'''

#@markdown ##DESIGN CRITERIA
#@markdown
#@markdown *Default to Grade = 100, Min_K_Values = 1*
Max_Grade_Percent = 7 #@param {type:"number"}
Min_K_Value_Sag = 1 #@param {type:"number"}
Min_K_Value_Crest = 113 #@param {type:"number"}

#@markdown
#@markdown ____________________________________________________________
#@markdown
#@markdown ##USER-DEFINED DATA
#@markdown
#@markdown *Only needed if "Guess Initial Values" was selected*
#@markdown
if  Initial_Value_Type == "Guess Initial Values":
  Number_Of_Curves = 5 #@param {type:"integer"}
  Average_Curve_Length_FT = 200 #@param {type:"integer"}
else:
  Number_Of_Curves = int( (len(g_arr)-2) / 2)
print("Number of Curves: ", Number_Of_Curves)

#@markdown
#@markdown ____________________________________________________________
#@markdown
#@markdown ##PROCESSING SPEED
#@markdown
Processing_Speed = "Very Fast, Very Low Accuracy" #@param ["Very Fast, Very Low Accuracy", "Fast, Low Accuracy", "Medium Speed/Accuracy", "Slow, High Accuracy", "Very Slow, Very High Accuracy"]

#@markdown
#@markdown ____________________________________________________________
#@markdown
#@markdown ##ROUNDING PRECISION
#@markdown
#@markdown *Note: Does not impact Processing Speed*
#@markdown
Station_Rounding = "Nearest 10 ft" #@param ["Nearest 100 ft", "Nearest 50 ft", "Nearest 10 ft", "Nearest 5 ft", "Nearest 1 ft", "No Rounding"]
Elevation_Rounding = "Nearest 0.1 ft" #@param ["Nearest 1 ft", "Nearest 0.5 ft", "Nearest 0.1 ft", "Nearest 0.05 ft", "Nearest 0.01 ft", "No Rounding"]
Curve_Length_Rounding = "Nearest 5 ft" #@param ["Nearest 100 ft", "Nearest 50 ft", "Nearest 10 ft", "Nearest 5 ft", "Nearest 1 ft", "No Rounding"]

#@markdown
#@markdown ____________________________________________________________
#@markdown
#@markdown ##(optional) PARAMETER CONSTRAINTS
#@markdown
#@markdown *Includes: K-Value, Curve Length, Slopes for specific curves/tangents*
#@markdown
#@markdown *Example: 0<M1<2, -3<M3<-1*
#@markdown
Constraint_Str = "1.35\u003CM1\u003C1.45, 0.6\u003CM4\u003C0.8" #@param {type:"string"}
def parse_contraints(c_str):
  str_spl = c_str.split(",")
  arr = []
  for s in str_spl:
    t = s.split("<")
    s_type = t[1][0]
    s_num = int(t[1][1:])
    s_low = float(t[0])
    s_high = float(t[2])
    arr += [[ s_type, s_num, s_low, s_high ]]
  return arr
user_constraints = parse_contraints(Constraint_Str)

#@markdown
#@markdown ____________________________________________________________
#@markdown
#@markdown ##(optional) UPPER/LOWER BOUNDS
#@markdown
#@markdown *Forces optimization to stay above/below certain distance from profile. Default Values = -100 & 100.*
#@markdown
#@markdown *Example:  Lower Bounds = -1 means profile will not go more than one foot below survey.*
#@markdown
Lower_Bounds_FT = -100 #@param {type:"number"}
Upper_Bounds_FT = 100 #@param {type:"number"}

# Global Values
number_of_params = (Number_Of_Curves + 2)*3 - 2

'''
____________________________________________________________________________
STEP 1:
Pre-Processing Initial X & Y Values
____________________________________________________________________________
'''
# Get Number of Points from processing speed
num_of_pts = 75
if Processing_Speed == "Very Fast, Very Low Accuracy":
  num_of_pts = 15
if Processing_Speed == "Fast, Low Accuracy":
  num_of_pts = 35
if Processing_Speed == "Slow, High Accuracy":
  num_of_pts = 150
if Processing_Speed == "Very Slow, Very High Accuracy":
  num_of_pts = 400

#Create initial x-actual values and set x-min = 0
global XM
x_actual = mydata_arr_T[0]
XM = min(x_actual)
x_actual = x_actual - XM

#Create initial y-actual values and set y-min = 0
global YM
y_actual = mydata_arr_T[1]
YM = min(y_actual)
y_actual = y_actual - YM+10

x_end_range = int(max(x_actual))
x_vals = list(range(0, x_end_range, int(x_end_range / num_of_pts)))
y_vals = []

# Generate new y_vals
for v in x_vals:
  weights = []
  for temp_x in x_actual:
    try:
      weights += [1/((temp_x - v)**4)]
    except:
      weights += [0]
  weights = weights / sum(weights)

  y_temp_sum = 0
  for y in range(len(y_actual)):
    y_temp_sum += weights[y] * y_actual[y]
  y_vals += [y_temp_sum]

x_actual = np.array(x_vals)
x_actual = np.array(x_vals)[1:len(x_actual)-2]
y_actual = np.array(y_vals)
y_actual = np.array(y_vals)[1:len(y_actual)-2] - 10

'''
____________________________________________________________________________
STEP 2:
Set Up Initial Equations and Files
____________________________________________________________________________
'''
#Open Output Files
rand_var = str(rand.random())
txt_file = file_name1 + rand_var + '_txt.txt'
tfile = open(txt_file, 'a')

csv_file = 'guess_export' + rand_var + '.csv'
cfile = open(csv_file, 'a')

'''
Create Initial Equation Type 1: From Imported EXCEL File
____________________________________________________________________________
'''
if  Initial_Value_Type == "Import EXCEL of Init Values":
  x_temp = []
  y_temp = []
  L_temp = []

# Create intial parameters from inported Excel
  for g in g_arr:
    split = g[0].split()
    for s in range(len(split)):
      if s==0:
        x_temp += [float(split[s]) - XM]
      elif s==1:
        y_temp += [float(split[s]) - YM]
      else:
        L_temp += [float(split[s])]
  init_param_temp = x_temp + y_temp + L_temp
  init_params = np.array(init_param_temp)


'''
Create Initial Equation Type 2: From Polynomial Model
____________________________________________________________________________
'''
if Initial_Value_Type == "Guess Initial Values":

  #polynomial fit with degree = Number Of Curves + 1
  poly_model = np.polyfit(x_actual, y_actual, Number_Of_Curves + 1)
  #print(poly_model)

  #Flip Polynomial for Derivative function, flip back for consistency
  poly_model_rev = np.flip(poly_model)
  deriv_poly = [poly_model_rev[i] * i for i in range(1, len(poly_model_rev))]
  deriv_poly= deriv_poly[::-1]
  #print(deriv_poly)

  #Find Zeros of Derivative (local mins/maxes = PVI x-values)
  x_min_roots = np.sort(np.roots(deriv_poly))
  #print(x_min_roots)

  #Fill Initial Parameters
  init_params = np.zeros(number_of_params)
  x_start, x_end =  x_actual[0], x_actual[len(x_actual)-1]
  y_start, y_end =  y_actual[0], y_actual[len(y_actual)-1]

  # Fill Initial Parameters (x-values)
  init_params[0] = x_start
  for xs in range(1, Number_Of_Curves + 1):
    temp_x = x_min_roots[xs-1]
    if temp_x <= x_start:
      temp_x = x_start + 10
    elif temp_x >= x_end:
      temp_x = x_end - 10
    init_params[xs] = temp_x
  init_params[Number_Of_Curves + 1] = x_end

  # Fill Initial Parameters (y-values)
  init_params[Number_Of_Curves + 2] = y_start
  for ys in range(Number_Of_Curves + 3, 2*(Number_Of_Curves + 2) - 1):
    init_params[ys] = np.polyval(poly_model, init_params[ys - Number_Of_Curves - 2])
  init_params[2*(Number_Of_Curves + 2) - 1] = y_end

  # Fill Initial Parameters (curve lengths)
  for cs in range(2*(2+Number_Of_Curves), number_of_params):
    init_params[cs] = Average_Curve_Length_FT

# Lengthen Tangents on Either Side
x_extension = 2000
temp_m_start = (init_params[Number_Of_Curves + 3] - init_params[Number_Of_Curves + 2] ) / (init_params[1] - init_params[0])
temp_m_end = (init_params[2*Number_Of_Curves + 3] - init_params[2*Number_Of_Curves + 2] ) / (init_params[Number_Of_Curves + 1] - init_params[Number_Of_Curves])

init_params[0] = init_params[0] - x_extension
init_params[Number_Of_Curves + 1] = init_params[Number_Of_Curves + 1] + x_extension

init_params[Number_Of_Curves + 2] = init_params[Number_Of_Curves + 2] + x_extension * temp_m_start
init_params[2*Number_Of_Curves + 3] = init_params[2*Number_Of_Curves + 3] + x_extension * temp_m_end


'''
____________________________________________________________________________
STEP 3:
Generate Optimization Equation "f"
____________________________________________________________________________
'''
def f(params):
  total_error = 0

  eq_list = get_eq_from_params(params)[0]
  func_ranges = get_eq_from_params(params)[1]

  #Calculate Error
  for x_index in range(len(x_actual)):
    cont_loop = True
    c = 0
    x = x_actual[x_index]
    while cont_loop:
      if x < func_ranges[c] or c == len(func_ranges) - 1:
        if c % 2 == 0:
          y_calc = eq_list[c][0]*x + eq_list[c][1]
        else:
          y_calc = eq_list[c][0]*x**2 + eq_list[c][1]*x + eq_list[c][2]
        cont_loop = False
      c += 1
    diff = y_calc - y_actual[x_index]
    if diff < Lower_Bounds_FT or diff > Upper_Bounds_FT:
      total_error += bounds_error
    else:
      total_error += (diff)**2
  #print(total_error)
  return total_error

'''
____________________________________________________________________________
STEP 4:
Calculating Dynamic Constraints
____________________________________________________________________________
'''

def constr_helper(h):
  #Create First Constraint - Curve Length 1
  arr = np.array([ h[1] - h[0] + h[2*(Number_Of_Curves+2)] ])
  for c in range(Number_Of_Curves):
    # Add Curve Overlap Constraint
    if c < Number_Of_Curves - 1:
      append_curve_overlap = [h[c+1] + h[c+2] + h[2*(Number_Of_Curves+2) + c] + h[2*(Number_Of_Curves+2) + c + 1] ]
      arr = np.append(arr, append_curve_overlap)


    # Add Max Grade Constraint
    m_temp = 100*abs( ( h[c + Number_Of_Curves + 3] - h[c + Number_Of_Curves + 2] ) / ( h[c+1] - h[c] ))
    append_max_grade = [Max_Grade_Percent - m_temp]
    arr = np.append(arr, append_max_grade)

    # Add K-Value Constraint
    m0 = 100*( h[c + Number_Of_Curves + 3] - h[c + Number_Of_Curves + 2] ) / ( h[c+1] - h[c] )
    m1 = 100*( h[c + Number_Of_Curves + 4] - h[c + Number_Of_Curves + 3] ) / ( h[c+2] - h[c+1] )
    L = h[2*(Number_Of_Curves+2) + c]
    k_crest = L / (m0 - m1)
    k_sag = L / (m1 - m0)

    if m0 > m1:
      append_k_crest = [k_crest - Min_K_Value_Crest]
      arr = np.append(arr, append_k_crest)
    else:
      append_k_sag = [k_sag - Min_K_Value_Sag]
      arr = np.append(arr, append_k_sag)

  for u in user_constraints:
    c_type = u[0] # M, ...
    i = u[1] # 1, 2, 3, ...
    if c_type == "M":
      m_temp = 100*( ( h[i + Number_Of_Curves + 2] - h[i + Number_Of_Curves + 1] ) / ( h[i] - h[i-1] ))
      append_grade_low = [m_temp - u[2]]
      append_grade_high = [u[3] - m_temp]
      arr = np.append(arr, append_grade_low)
      arr = np.append(arr, append_grade_high)
    else:
      print("Error: Constraint String Not Entered Properly")


  return arr

constr_func = lambda x: constr_helper(x)
nonlin_con = NonlinearConstraint(constr_func, 0., np.inf )

'''
____________________________________________________________________________
STEP 5:
Running Optimization
____________________________________________________________________________
'''

initial_guess = init_params

#result = optimize.minimize(f, initial_guess, method='SLSQP')
#result = optimize.minimize(f, initial_guess, method='SLSQP', constraints=cons)
#result = optimize.minimize(f, initial_guess, method='trust-constr', constraints=cons)
result = optimize.minimize( f, initial_guess, method='trust-constr', jac='2-point', constraints = nonlin_con )

# , options={'maxiter':3})\
fitted_params = result.x
if result.success:
  print("Optimization Successful")
else:
  print("ERROR - Result was not a success according to the ML Model")

'''
____________________________________________________________________________
PART 6:
Printing/Exporting Results
____________________________________________________________________________
'''

def rounded_scaled_params(p):
  adder = 0.50001
  sta_round = 0
  if Station_Rounding != "No Rounding":
    sta_round = float(Station_Rounding.split()[1])
  elev_round = 0
  if Elevation_Rounding != "No Rounding":
   elev_round = float(Elevation_Rounding.split()[1])
  curve_round = 0
  if Curve_Length_Rounding != "No Rounding":
    curve_round = float(Curve_Length_Rounding.split()[1])

  new_p = copy.deepcopy(p)
  for i in range(len(p)):
    if i < Number_Of_Curves + 2:
      if  sta_round > 0:
        new_p[i] = sta_round * round( (p[i] + XM + sta_round * adder) / sta_round)
      else:
        new_p[i] = p[i] + XM
    if  i >= Number_Of_Curves + 2 and i < 2*(Number_Of_Curves + 2):
      if elev_round > 0:
        new_p[i] = elev_round * round( (p[i] + YM + elev_round * adder) / elev_round)
      else:
        new_p[i] = p[i] + YM
    if  curve_round > 0 and i >= 2*(Number_Of_Curves + 2):
      new_p[i] = curve_round * round( (p[i] + curve_round * adder) / curve_round)

  return new_p

def scaled_params(p):
  new_p = copy.deepcopy(p)
  for i in range(len(p)):
    if i < Number_Of_Curves + 2:
      new_p[i] = p[i] + XM
    if  i >= Number_Of_Curves + 2 and i < 2*(Number_Of_Curves + 2):
      new_p[i] = p[i] + YM
  return new_p

rounded_params = rounded_scaled_params(fitted_params)

print()
print("AVERAGE VERTICAL ERROR: ", round(calc_total_error(rounded_params)*12, 2), "inches")

text_str = ""
# Print Results to Screen
for PVI in range(Number_Of_Curves+2):
  STA = rounded_params[PVI]
  ELEV = rounded_params[PVI+Number_Of_Curves+2]
  print()
  print("PVI ", PVI+1, ": STA. = ", STA, ". ELEV. = ", ELEV )

  if PVI < Number_Of_Curves + 1:
    M = get_eq_from_params(rounded_params)[2][PVI]
    print("Slope (%)              M", PVI+1, " = " , round(M*100, 2))

  if PVI > 0 and PVI < Number_Of_Curves + 1:
    LEN = rounded_params[2*(2+Number_Of_Curves)+PVI-1]
    K = round(get_eq_from_params(rounded_params)[3][PVI-1], 2)
    print("Curve Length (ft)  L" , PVI , " = ", LEN)
    print("K-Value                 K", PVI , " = ",  K)
    temp_txt_str = str(STA) + " " +  str(ELEV) + " " + str(LEN) + "\n"
  else:
    temp_txt_str = str(STA) + " " +  str(ELEV) + " " + "\n"
  text_str += temp_txt_str

#Plot Points
plt.scatter(x_actual+XM, y_actual+YM)

#Plot Initial Eq
scaled_init = scaled_params(init_params)
print_graph_from_params(scaled_init)
fr1 = get_eq_from_params(scaled_init)[1]
#plt.scatter(fr1+XM, get_yArray_from_xArray_and_params(init_params, fr1)+YM)

#Plot Final Eq
print_graph_from_params(rounded_params, 'b')
fr2 = get_eq_from_params(rounded_params)[1]
#plt.scatter(fr2+XM, get_yArray_from_xArray_and_params(fitted_params, fr2)+YM)

plt.show()

# Writes the data to the TEXT file and saves the TEXT file
tfile.write(text_str)
tfile.close()
cfile.close()

# Download TXT
files.download(txt_file)
#files.download(csv_file)

#@title Scrap Work

import numpy as np
from bokeh.plotting import figure, show
from bokeh.io import output_notebook

# Call once to configure Bokeh to display plots inline in the notebook.
output_notebook()

N = 4000
x = np.random.random(size=N) * 100
y = np.random.random(size=N) * 100
radii = np.random.random(size=N) * 1.5
colors = ["#%02x%02x%02x" % (r, g, 150) for r, g in zip(np.floor(50+2*x).astype(int), np.floor(30+2*y).astype(int))]

p = figure()
p.circle(x, y, radius=radii, fill_color=colors, fill_alpha=0.6, line_color=None)
show(p)